/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.xmudronc;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

import org.jline.terminal.Terminal;
import org.jline.utils.NonBlockingReader;

public class Snajk {
    private Integer score = 0;
    private Integer multiplier = 1;
    private Integer multiplierPickupCount = 0;
    private Boolean comboMeterRunning = false;
    private ArrayList<Point> food = new ArrayList<>();
    private NonBlockingReader reader;
    private Terminal terminal;
    private Boolean running = false;
    private String direction = "N";
    private int delay = 150;
    private Integer width;
    private Integer height;
    private Segment mainSegment;
    private Thread combo;
    private Thread comboMeter = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                comboMeterRunning = true;
                Thread.sleep(5000);
                multiplierPickupCount = 0;
                multiplier = 1;
                comboMeterRunning = false;
            } catch (InterruptedException e) {}
        }
    });
    private Thread input = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                if (reader != null) {
                    while (running) {
                        Integer value = reader.read();
                        if (value >= 65 && value <= 90) {
                            value += 32;
                        }
                        if (value == 113 || value == 27) {
                            running = false;
                            move.interrupt();
                            Menu menu = new Menu();
                            menu.init();
                        } else {
                            move(value);
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    });
    private Thread move = new Thread(new Runnable() {
        @Override
        public void run() {
            while (running) {
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                    System.out.print("GAME ENDED BY USER");
                }
                switch (direction) {
                    case "L":
                        if (mainSegment.getX() > 2) {
                            mainSegment.setY(mainSegment.getY() + 0);
                            mainSegment.setX(mainSegment.getX() - 2);
                            if (checkMove(mainSegment)) {
                                printSegment(mainSegment);
                            } else {
                                gover();
                            }
                        }
                        break;
                    case "R":
                        if (mainSegment.getX() < (width*2)-2) {
                            mainSegment.setY(mainSegment.getY() + 0);
                            mainSegment.setX(mainSegment.getX() + 2);
                            if (checkMove(mainSegment)) {
                                printSegment(mainSegment);
                            } else {
                                gover();
                            }
                        }    
                        break;
                    case "U":
                        if (mainSegment.getY() > 1) {
                            mainSegment.setY(mainSegment.getY() - 1);
                            mainSegment.setX(mainSegment.getX() + 0);
                            if (checkMove(mainSegment)) {
                                printSegment(mainSegment);
                            } else {
                                gover();
                            }
                        }
                        break;
                    case "D":
                        if (mainSegment.getY() < height) {
                            mainSegment.setY(mainSegment.getY() + 1);
                            mainSegment.setX(mainSegment.getX() + 0);
                            if (checkMove(mainSegment)) {
                                printSegment(mainSegment);
                            } else {
                                gover();
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    });

    public Snajk(Terminal terminal, NonBlockingReader reader, Integer width, Integer height) {
        this.terminal = terminal;
        this.reader = reader;
        this.width = width;
        this.height = height;
    }

    public void move(Integer key) {
        switch (key) {
            case 97: // a
                if (direction != "R") {
                    direction = "L";                    
                }
                break;
            case 100: // d
                if (direction != "L") {
                    direction = "R";
                }
                break;
            case 115: // s
                if (direction != "U") {
                    direction = "D";
                }
                break;
            case 119: // w
                if (direction != "D") {
                    direction = "U";
                }
                break;
            default:
                break;
        }
    }

    public void comboInit() {
        multiplierPickupCount++;
        if (multiplierPickupCount % 5 == 0) {
            multiplier++;
        }
        if (comboMeterRunning) {
            combo.interrupt();
        }
        combo = new Thread(comboMeter);
        combo.start();
    }

    public Boolean checkCollisionFood() {
        Point toRemove = null;
        for (Point _point : food) {
            if (mainSegment.getX() == _point.getX() && mainSegment.getY() == _point.getY()) {
                mainSegment.addSegment(new Segment());
                this.score += _point.getValue() * this.multiplier;
                toRemove = _point;
                break;
            }
        }
        if (toRemove != null) {
            food.remove(toRemove);
            comboInit();
        }
        if (food.size() == 0) {
            gwin();
        }
        return true;
    }

    public Boolean checkCollisionSelf(Segment segment) {
        if (segment != null) {
            if (segment.getX().equals(mainSegment.getX()) && segment.getY().equals(mainSegment.getY())) {
                return true;
            } else {
                if (segment.getNext() != null) {
                    return checkCollisionSelf(segment.getNext());
                } else {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    public void gover() {
        System.out.print(String.format("%c[%d;%df", 0x1B, 1, 41));
        System.out.print("GOVER");
        running = false;        
        try {
            terminal.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        this.input.interrupt();
        this.move.interrupt();
        System.exit(0);
    }

    public void gwin() {
        System.out.print(String.format("%c[%d;%df", 0x1B, 1, 41));
        System.out.print("GWIN");
        running = false;        
        try {
            terminal.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        this.input.interrupt();
        this.move.interrupt();
        System.exit(0);
    }

    public boolean checkMove(Segment segment) {
        /*System.out.print(String.format("%c[%d;%df", 0x1B, 1, 1));
        System.out.print(mainSegment.getX() + " " + mainSegment.getY());*/
        System.out.print(String.format("%c[%d;%df", 0x1B, width, 1));
        System.out.print("SCR:" + this.score + " MLT: " + this.multiplier + "x");
        if (segment.getX() <= 2 || segment.getX() >= (width*2)-2 || segment.getY() <= 1
                || segment.getY() >= height) {
            return false;
        } else {
            Boolean selfCollision = checkCollisionSelf(mainSegment.getNext());
            if (selfCollision) {
                return false;
            } else {
                return checkCollisionFood();
            }
        }
    }

    public void printToXY(Integer x, Integer y, String print, String fgr, String bgr) {
        System.out.print(String.format("%c[%d;%df", 0x1B, y, x));
        System.out.print(print);
    }

    public void printSegment(Segment segment) {
        if (segment != null) {
            String col = "\u001B[32m";
            if (segment == mainSegment) {
                col = "\u001B[34m";
            }
            printToXY(segment.getX(), segment.getY(), col + Symbol.BLOCK.value, "fgr", "bgr");
            if (segment.getNext() != null) {
                Segment next = segment.getNext();
                next.setX(segment.getPrevX());
                next.setY(segment.getPrevY());
                printSegment(next);
            } else {
                printToXY(segment.getPrevX(), segment.getPrevY(), Symbol.EMPTY.value, "fgr", "bgr");
            }
        }
    }

    public void generatePoints() {
        while (food.size() < (width*height)*0.1) {
            Integer x = new Random().nextInt(width*2 - 4) + 2;
            Integer y = new Random().nextInt(height - 2) + 2;
            Point newPoint = new Point(x, y);
            if (!food.contains(newPoint) && newPoint.getX() % 2 != 0 && !startCollision(newPoint)) {
                food.add(newPoint);
                System.out.print(String.format("%c[%d;%df", 0x1B, newPoint.getY(), newPoint.getX()));
                System.out.print("\u001B[33m" + Symbol.FOOD.value);
            }
        }
    }

    public boolean startCollision(Point point) {
        if (((point.getX() == 3) || (point.getX() == 5)) && (point.getY() == 2)) {
            return true;
        } else {
            return false;
        }
    }

    public void start() {
        this.running = true;
        this.input.start();
        this.move.start();
    }

    public void init() throws IOException {
        generatePoints(); 
        this.mainSegment = new Segment(3, 2);
        Segment initSegment = new Segment(3, 2);
        initSegment.setPrev(this.mainSegment);
        this.mainSegment.setNext(initSegment);
        this.mainSegment.setX(5);
        this.mainSegment.setY(2);
        this.printSegment(this.mainSegment);
        this.start();
    }
}
