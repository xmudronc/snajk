/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.xmudronc;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

import org.jline.terminal.Size;
import org.jline.terminal.Terminal;
import org.jline.utils.NonBlockingReader;

public class Snajk {
    private Integer score = 0;
    private Integer multiplier = 1;
    private Integer multiplierPickupCount = 0;
    private Boolean comboMeterRunning = false;
    private ArrayList<Point> food = new ArrayList<>();
    private NonBlockingReader reader;
    private Terminal terminal;
    private LogArea logArea;
    private Size startupSize;
    private Size runSize;
    private Boolean running = false;
    private String direction = "N";
    private int delay = 150;
    private Integer width;
    private Integer height;
    private Segment startSegment;
    private Segment mainSegment;
    private Thread combo;
    private Thread comboMeter = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                comboMeterRunning = true;
                Thread.sleep(5000);
                multiplierPickupCount = 0;
                multiplier = 1;
                comboMeterRunning = false;
            } catch (InterruptedException e) {}
        }
    });
    private Thread input = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                if (reader != null) {
                    while (running) {
                        Integer value = reader.read();
                        if (value >= 65 && value <= 90) {
                            value += 32;
                        }
                        if (value == 112) {
                            gover();
                        } else {
                            move(value);
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    });
    private Thread move = new Thread(new Runnable() {
        @Override
        public void run() {
            while (running) {
                try {
                    Thread.sleep(delay);
                    switch (direction) {
                        case "L":
                            if (mainSegment.getX() > 2) {
                                mainSegment.setY(mainSegment.getY() + 0);
                                mainSegment.setX(mainSegment.getX() - 2);
                                if (checkMove(mainSegment)) {
                                    printSegment(mainSegment);
                                } else {
                                    gover();
                                }
                            }
                            break;
                        case "R":
                            if (mainSegment.getX() < (width*2)-2) {
                                mainSegment.setY(mainSegment.getY() + 0);
                                mainSegment.setX(mainSegment.getX() + 2);
                                if (checkMove(mainSegment)) {
                                    printSegment(mainSegment);
                                } else {
                                    gover();
                                }
                            }    
                            break;
                        case "U":
                            if (mainSegment.getY() > 1) {
                                mainSegment.setY(mainSegment.getY() - 1);
                                mainSegment.setX(mainSegment.getX() + 0);
                                if (checkMove(mainSegment)) {
                                    printSegment(mainSegment);
                                } else {
                                    gover();
                                }
                            }
                            break;
                        case "D":
                            if (mainSegment.getY() < height) {
                                mainSegment.setY(mainSegment.getY() + 1);
                                mainSegment.setX(mainSegment.getX() + 0);
                                if (checkMove(mainSegment)) {
                                    printSegment(mainSegment);
                                } else {
                                    gover();
                                }
                            }
                            break;
                        default:
                            break;
                    }
                } catch (InterruptedException | IOException e) {
                    System.out.print("GAME ENDED BY USER");
                }
            }
        }
    });

    public Snajk(Terminal terminal, NonBlockingReader reader, LogArea logArea, Size startupSize, Size runSize) {
        this.terminal = terminal;
        this.reader = reader;
        this.logArea = logArea;
        this.startupSize = startupSize;
        this.runSize = runSize;
        this.width = runSize.getRows();
        this.height = runSize.getRows();
        this.startSegment = new Segment(width-1, height/2);
    }

    public void move(Integer key) {
        switch (key) {
            case 97: // a
                if (direction != "R") {
                    direction = "L";                    
                }
                break;
            case 100: // d
                if (direction != "L") {
                    direction = "R";
                }
                break;
            case 115: // s
                if (direction != "U") {
                    direction = "D";
                }
                break;
            case 119: // w
                if (direction != "D") {
                    direction = "U";
                }
                break;
            default:
                break;
        }
    }

    public void comboInit() {
        multiplierPickupCount++;
        if (multiplierPickupCount % 5 == 0) {
            multiplier++;
        }
        if (comboMeterRunning) {
            combo.interrupt();
        }
        combo = new Thread(comboMeter);
        combo.start();
    }

    public Boolean checkCollisionFood() throws IOException {
        Point toRemove = null;
        for (Point _point : food) {
            if (mainSegment.getX() == _point.getX() && mainSegment.getY() == _point.getY()) {
                mainSegment.addSegment(new Segment());
                this.score += _point.getValue() * this.multiplier;
                toRemove = _point;
                break;
            }
        }
        if (toRemove != null) {
            food.remove(toRemove);
            comboInit();
        }
        if (food.size() == 0) {
            gover();
        }
        return true;
    }

    public Boolean checkCollisionSelf(Segment segment) {
        if (segment != null) {
            if (segment.getX().equals(mainSegment.getX()) && segment.getY().equals(mainSegment.getY())) {
                return true;
            } else {
                if (segment.getNext() != null) {
                    return checkCollisionSelf(segment.getNext());
                } else {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    public void gover() throws IOException {
        running = false;
        logArea.printToLogOverwritable("GAME OVER");
        Menu menu = new Menu(terminal, reader, startupSize, runSize);
        menu.initPlayAreaOnly(logArea); 
    }

    public boolean checkMove(Segment segment) throws IOException {
        /*System.out.print(String.format("%c[%d;%df", 0x1B, 1, 1));
        System.out.print(mainSegment.getX() + " " + mainSegment.getY());*/

        //update or move
        System.out.print(String.format("%c[%d;%df", 0x1B, 4, (width*2)+9));
        System.out.print("\u001B[37m" + this.score);
        System.out.print(String.format("%c[%d;%df", 0x1B, 6, (width*2)+21));
        System.out.print("\u001B[37m" + this.multiplier + "x  ");

        if (segment.getX() <= 2 || segment.getX() >= (width*2)-2 || segment.getY() <= 1 || segment.getY() >= height-1) {
            return false;
        } else {
            Boolean selfCollision = checkCollisionSelf(mainSegment.getNext());
            if (selfCollision) {
                return false;
            } else {
                return checkCollisionFood();
            }
        }
    }

    public void printToXY(Integer x, Integer y, String print, String fgr, String bgr) {
        System.out.print(String.format("%c[%d;%df", 0x1B, y, x));
        System.out.print(print);
    }

    public void printSegment(Segment segment) {
        if (segment != null) {
            String col = "\u001B[42m";
            if (segment == mainSegment) {
                col = "\u001B[44m";
            }
            printToXY(segment.getX(), segment.getY(), col + Symbol.EMPTY.value, "fgr", "bgr");
            if (segment.getNext() != null) {
                Segment next = segment.getNext();
                next.setX(segment.getPrevX());
                next.setY(segment.getPrevY());
                printSegment(next);
            } else {
                if (segment.getPrevX() != null && segment.getPrevY() != null) {
                    printToXY(segment.getPrevX(), segment.getPrevY(), "\u001B[0m" + Symbol.EMPTY.value, "fgr", "bgr");
                }
            }
        }
        System.out.print("\u001B[0m");
    }

    public boolean isPointInSafeArea(Point point) {
        if (point.getX() < startSegment.getX()-5 && point.getX() > startSegment.getX()+5 && point.getY() < startSegment.getY()-2 && point.getY() > startSegment.getY()+2) {
            return true;
        } 
        return false;
    }

    public void generatePoints() {
        while (food.size() < (width*height)*0.1) {
            Integer x = new Random().nextInt(width*2 - 4) + 3;
            Integer y = new Random().nextInt(height - 3) + 2;
            Point newPoint = new Point(x, y);
            if (!food.contains(newPoint) && newPoint.getX() % 2 != 0 && !startCollision(newPoint) && !isPointInSafeArea(newPoint)) {
                food.add(newPoint);
                System.out.print(String.format("%c[%d;%df", 0x1B, newPoint.getY(), newPoint.getX()));
                System.out.print("\u001B[43m" + Symbol.EMPTY.value);
            }
        }
    }

    public boolean startCollision(Point point) {
        if (((point.getX() == 3) || (point.getX() == 5)) && (point.getY() == 2)) {
            return true;
        } else {
            return false;
        }
    }

    public void start() {
        this.running = true;
        this.input.start();
        this.move.start();
    }

    public void init() throws IOException {
        logArea.printToLogOverwritable("GAME STARTED");
        generatePoints(); 
        this.mainSegment = startSegment;
        this.printSegment(this.mainSegment);
        this.start();
    }
}
